<!DOCTYPE html>
<html lang="en">
  <head>
    <title>&lt;model-viewer&gt; template</title>
    <meta charset="utf-8" />
    <meta name="description" content="&lt;model-viewer&gt; template" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link type="text/css" href="./styles.css" rel="stylesheet" />
    <!-- OPTIONAL: The :focus-visible polyfill removes the focus ring for some input types -->
    <script
      src="https://unpkg.com/focus-visible@5.0.2/dist/focus-visible.js"
      defer
    ></script>

    <!-- MDL -->
    <link rel="stylesheet" href="./material.min.css">
    <script src="./material.min.js"></script>
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">

    <style>
      .bottom-right {
        position: fixed;
        bottom: 10px;
        right: 10px;
      }
    </style>
  </head>
  <body>
    <!-- ---------------------------------------------------------------------------------- -->
    <model-viewer
    id="v"
    bounds="tight"
    camera-controls
    oncontextmenu="return false;"
    min-field-of-view="10deg"
    shadow-intensity="0.4"
    shadow-softness="0.4"
    src="scene.gltf"
    >
  </model-viewer>
  <!-- Colored FAB button -->
  <button class="bottom-right mdl-button mdl-js-button mdl-button--fab mdl-button--mini-fab mdl-button--colored"
    onmouseup="changeCameraTarget()"
    >
    <i class="material-icons">add</i>
  </button>
    <!-- <button class="stack-top" onclick="changeCameraTarget()">Hotspot</button> -->
    
    <!-- ---------------------------------------------------------------------------------- -->
    <script type="module">
      const modelViewer = document.querySelector("#v");
      const tapDistance = 2;
      let panning = false;
      let panX, panY;
      let startX, startY;
      let lastX, lastY;
      let metersPerPixel;
      
      const startPan = () => {
        const orbit = modelViewer.getCameraOrbit();
        const { theta, phi, radius } = orbit;
        const psi = theta - modelViewer.turntableRotation;
        metersPerPixel =
        (0.75 * radius) / modelViewer.getBoundingClientRect().height;
        panX = [-Math.cos(psi), 0, Math.sin(psi)];
        panY = [
          -Math.cos(phi) * Math.sin(psi),
          Math.sin(phi),
          -Math.cos(phi) * Math.cos(psi),
        ];
        modelViewer.interactionPrompt = "none";
      };
      
      const movePan = (thisX, thisY) => {
        const dx = (thisX - lastX) * metersPerPixel;
        const dy = (thisY - lastY) * metersPerPixel;
        lastX = thisX;
        lastY = thisY;
        
        const target = modelViewer.getCameraTarget();
        target.x += dx * panX[0] + dy * panY[0];
        target.y += dx * panX[1] + dy * panY[1];
        target.z += dx * panX[2] + dy * panY[2];
        modelViewer.cameraTarget = `${target.x}m ${target.y}m ${target.z}m`;

        // This pauses turntable rotation
        modelViewer.dispatchEvent(
          new CustomEvent("camera-change", {
            detail: { source: "user-interaction" },
          })
        );
      };

      const recenter = (pointer) => {
        panning = false;
        if (
          Math.abs(pointer.clientX - startX) > tapDistance ||
          Math.abs(pointer.clientY - startY) > tapDistance
        )
          return;
        const hit = modelViewer.positionAndNormalFromPoint(
          pointer.clientX,
          pointer.clientY
        );
        modelViewer.cameraTarget =
          hit == null ? "auto auto auto" : hit.position.toString();
      };

      modelViewer.addEventListener(
        "mousedown",
        (event) => {
          startX = event.clientX;
          startY = event.clientY;
          panning =
            event.button === 2 ||
            event.ctrlKey ||
            event.metaKey ||
            event.shiftKey;
          if (!panning) return;

          lastX = startX;
          lastY = startY;
          startPan();
          event.stopPropagation();
        },
        true
      );

      modelViewer.addEventListener(
        "touchstart",
        (event) => {
          const { targetTouches, touches } = event;
          startX = targetTouches[0].clientX;
          startY = targetTouches[0].clientY;
          panning =
            targetTouches.length === 2 &&
            targetTouches.length === touches.length;
          if (!panning) return;

          lastX = 0.5 * (targetTouches[0].clientX + targetTouches[1].clientX);
          lastY = 0.5 * (targetTouches[0].clientY + targetTouches[1].clientY);
          startPan();
        },
        true
      );

      self.addEventListener(
        "mousemove",
        (event) => {
          if (!panning) return;

          movePan(event.clientX, event.clientY);
          event.stopPropagation();
        },
        true
      );

      modelViewer.addEventListener(
        "touchmove",
        (event) => {
          if (!panning || event.targetTouches.length !== 2) return;

          const { targetTouches } = event;
          const thisX =
            0.5 * (targetTouches[0].clientX + targetTouches[1].clientX);
          const thisY =
            0.5 * (targetTouches[0].clientY + targetTouches[1].clientY);
          movePan(thisX, thisY);
        },
        true
      );

      self.addEventListener(
        "mouseup",
        (event) => {
          // recenter(event);
        },
        true
      );

      modelViewer.addEventListener(
        "touchend",
        (event) => {
          if (event.targetTouches.length === 0) {
            recenter(event.changedTouches[0]);

            if (event.cancelable) {
              event.preventDefault();
            }
          }
        },
        true
      );
    </script>
    <script type = "text/javascript">
      var hotspotIndex = 0;
      var modelViewer
      var initialCameraTarget
      
      function changeCameraTarget() {
        if (!modelViewer)
          modelViewer = document.querySelector('#v');
        if (!initialCameraTarget) 
          initialCameraTarget = document.querySelector('#v').getCameraTarget();
        
        const hotspots = [
          "1.036162190887431m 0.45048296503005636m -0.010360742858188554m",
          "0.9145105041420883m 0.07904832035079451m -1.9739225672798495m",
          "0.1134913113892595m 0.20652078475995328m -0.0484623126430912m"
        ];
        
        // position="1.036162190887431m 0.45048296503005636m -0.010360742858188554m"
        // document.getElementById("v").setAttribute("camera-target", "0m 0m 0m");
        //document.getElementById("v").setAttribute("camera-target", "1.036162190887431m 0.45048296503005636m -0.010360742858188554m");
        modelViewer.setAttribute("camera-target", hotspots[hotspotIndex]);
        modelViewer.setAttribute("field-of-view", "10deg");

        ++hotspotIndex;
        if (hotspotIndex > hotspots.length) {
          hotspotIndex = 0;
          modelViewer.setAttribute("camera-target", initialCameraTarget);
          modelViewer.setAttribute("field-of-view", "auto");
        }
      }
    </script>
    <script src="script.js"></script>
    <!-- Loads <model-viewer> for browsers: -->
    <script
      type="module"
      src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"
    ></script>
  </body>
</html>
